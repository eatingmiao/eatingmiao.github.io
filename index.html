<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="少不更事">
<meta property="og:type" content="website">
<meta property="og:title" content="Eating's Notes">
<meta property="og:url" content="http://eatingmiao.github.io/index.html">
<meta property="og:site_name" content="Eating's Notes">
<meta property="og:description" content="少不更事">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Eating's Notes">
<meta name="twitter:description" content="少不更事">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> Eating's Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Eating's Notes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/29/compiler/" itemprop="url">
                  写一个Webpack Plugin需要了解的关键点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2018-03-29T00:00:00+08:00" content="2018-03-29">
              2018-03-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/29/compiler/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/29/compiler/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="事件流">事件流</h2><p>webpack 所有的功能都以 plugin 的方式集成在构建流程中，流程都是通过事件来控制的，每一个 plugin 就相当于event listener，apply 方法就相当于 emitter，在打包流程中调用相应的 apply 方法来触发 plugin。</p>
<p>在编写一个 plugin 前，需要了解 webpack 的事件流，根据功能选择合适的监听事件。</p>
<p>webpack 的事件流如下：</p>
<pre><code>         method                       event-name
------------------------------------------------------------------
applyPluginsBailResult           <span class="string">|   entry-option</span>
applyPlugins                     <span class="string">|   after-plugins</span>
applyPlugins                     <span class="string">|   after-resolvers</span>
applyPlugins                     <span class="string">|   environment</span>
applyPlugins                     <span class="string">|   after-environment</span>
applyPluginsAsync                <span class="string">|   before-run</span>
applyPluginsAsyncSeries          <span class="string">|   run</span>
applyPlugins                     <span class="string">|   normal-module-factory</span>
applyPlugins                     <span class="string">|   context-module-factory</span>
applyPlugins                     <span class="string">|   compile</span>
applyPlugins                     <span class="string">|   this-compilation</span>
applyPlugins                     <span class="string">|   compilation</span>
applyPluginsParallel             <span class="string">|   make</span>
applyPluginsAsyncWaterfall       <span class="string">|   before-resolve</span>
applyPluginsWaterfall            <span class="string">|   factory</span>
applyPluginsWaterfall            <span class="string">|   resolver</span>
applyPlugins                     <span class="string">|   resolve</span>
applyPlugins                     <span class="string">|   resolve-step</span>
applyPluginsParallelBailResult   <span class="string">|   file</span>
applyPluginsParallelBailResult   <span class="string">|   directory</span>
applyPlugins                     <span class="string">|   resolve-step</span>
applyPluginsParallelBailResult   <span class="string">|   result</span>
applyPluginsAsyncWaterfall       <span class="string">|   after-resolve</span>
applyPluginsBailResult           <span class="string">|   create-module</span>
applyPluginsWaterfall            <span class="string">|   module</span>
applyPlugins                     <span class="string">|   build-module</span>
applyPlugins                     <span class="string">|   normal-module-loader</span>
applyPluginsBailResult           <span class="string">|   program</span>
applyPluginsBailResult           <span class="string">|   statement</span>
applyPluginsBailResult           <span class="string">|   evaluate MemberExpression</span>
applyPluginsBailResult           <span class="string">|   evaluate Identifier document.write</span>
applyPluginsBailResult           <span class="string">|   call document.write</span>
applyPluginsBailResult           <span class="string">|   expression document.write</span>
applyPluginsBailResult           <span class="string">|   expression document</span>
applyPlugins                     <span class="string">|   succeed-module</span>
applyPlugins                     <span class="string">|   seal</span>
applyPlugins                     <span class="string">|   optimize</span>
applyPlugins                     <span class="string">|   optimize-modules</span>
applyPlugins                     <span class="string">|   after-optimize-modules</span>
applyPlugins                     <span class="string">|   optimize-chunks</span>
applyPlugins                     <span class="string">|   after-optimize-chunks</span>
applyPluginsAsyncSeries          <span class="string">|   optimize-tree</span>
applyPlugins                     <span class="string">|   after-optimize-tree</span>
applyPluginsBailResult           <span class="string">|   should-record</span>
applyPlugins                     <span class="string">|   revive-modules</span>
applyPlugins                     <span class="string">|   optimize-module-order</span>
applyPlugins                     <span class="string">|   before-module-ids</span>
applyPlugins                     <span class="string">|   optimize-module-ids</span>
applyPlugins                     <span class="string">|   after-optimize-module-ids</span>
applyPlugins                     <span class="string">|   record-modules</span>
applyPlugins                     <span class="string">|   revive-chunks</span>
applyPlugins                     <span class="string">|   optimize-chunk-order</span>
applyPlugins                     <span class="string">|   before-chunk-ids</span>
applyPlugins                     <span class="string">|   optimize-chunk-ids</span>
applyPlugins                     <span class="string">|   after-optimize-chunk-ids</span>
applyPlugins                     <span class="string">|   record-chunks</span>
applyPlugins                     <span class="string">|   before-hash</span>
applyPlugins                     <span class="string">|   hash</span>
applyPlugins                     <span class="string">|   hash-for-chunk</span>
applyPlugins                     <span class="string">|   chunk-hash</span>
applyPlugins                     <span class="string">|   after-hash</span>
applyPlugins                     <span class="string">|   before-chunk-assets</span>
applyPluginsWaterfall            <span class="string">|   global-hash-paths</span>
applyPluginsBailResult           <span class="string">|   global-hash</span>
applyPluginsWaterfall            <span class="string">|   bootstrap</span>
applyPluginsWaterfall            <span class="string">|   local-vars</span>
applyPluginsWaterfall            <span class="string">|   require</span>
applyPluginsWaterfall            <span class="string">|   module-obj</span>
applyPluginsWaterfall            <span class="string">|   module-require</span>
applyPluginsWaterfall            <span class="string">|   require-extensions</span>
applyPluginsWaterfall            <span class="string">|   asset-path</span>
applyPluginsWaterfall            <span class="string">|   startup</span>
applyPluginsWaterfall            <span class="string">|   module-require</span>
applyPluginsWaterfall            <span class="string">|   render</span>
applyPluginsWaterfall            <span class="string">|   module</span>
applyPluginsWaterfall            <span class="string">|   render</span>
applyPluginsWaterfall            <span class="string">|   package</span>
applyPluginsWaterfall            <span class="string">|   modules</span>
applyPluginsWaterfall            <span class="string">|   render-with-entry</span>
applyPluginsWaterfall            <span class="string">|   asset-path</span>
applyPlugins                     <span class="string">|   chunk-asset</span>
applyPlugins                     <span class="string">|   additional-chunk-assets</span>
applyPlugins                     <span class="string">|   record</span>
applyPluginsAsyncSeries          <span class="string">|   additional-assets</span>
applyPluginsAsyncSeries          <span class="string">|   optimize-chunk-assets</span>
applyPlugins                     <span class="string">|   after-optimize-chunk-assets</span>
applyPluginsAsyncSeries          <span class="string">|   optimize-assets</span>
applyPlugins                     <span class="string">|   after-optimize-assets</span>
applyPluginsAsyncSeries          <span class="string">|   after-compile</span>
applyPluginsBailResult           <span class="string">|   should-emit</span>
applyPluginsAsyncSeries          <span class="string">|   emit</span>
applyPluginsWaterfall            <span class="string">|   asset-path</span>
applyPluginsAsyncSeries          <span class="string">|   after-emit</span>
applyPlugins                     <span class="string">|   done</span>
</code></pre><h3 id="关键事件">关键事件</h3><ul>
<li>entry-option 初始化 option</li>
<li>run 编译入口</li>
<li>compile 开始编译</li>
<li>make 从 entry 递归分析模块及其依赖的模块，创建这些模块对象</li>
<li>build-module 构建模块，使用对应的loader加载</li>
<li>normal-module-loader 对loader加载完成的模块进行编译，生成AST</li>
<li>program 对AST进行遍历，收集依赖</li>
<li>seal 封装构建结果，抽取公共模块，优化 chunk</li>
<li>bootstrap 生成启动代码</li>
<li>after-compile 完成构建</li>
<li>emit 把各个 chunk 输出到结果文件</li>
<li>after-emit 完成输出 chunk</li>
</ul>
<h3 id="关键实体">关键实体</h3><ul>
<li>Module 模块是 webpack 的中的核心实体，使用 ModuleFactory 创建不同的Module</li>
<li>Dependency 每一个依赖的实体都包含一个指向被依赖的 Module 的字段</li>
<li>Template 每一个依赖都有相应的 Template，用来生成加载该依赖模块的js代码</li>
<li>Chunk 代码分离后的产物，按需加载的分块，装载了不同的 module</li>
</ul>
<p>要开发一个 webpack 的 plugin，其中最关键的两个对象就是 <a href="https://github.com/webpack/webpack/blob/master/lib/Compiler.js" target="_blank" rel="external">compiler</a> 和 <a href="https://github.com/webpack/webpack/blob/master/lib/Compilation.js" target="_blank" rel="external">compilation</a>。</p>
<h2 id="Compiler">Compiler</h2><blockquote>
<p>The compiler object represents the fully configured webpack environment. This object is built once upon starting webpack, and is configured with all operational settings including options, loaders, and plugins. When applying a plugin to the webpack environment, the plugin will receive a reference to this compiler. Use the compiler to access the main webpack environment</p>
</blockquote>
<p>Compiler 即编译器，用于配置和建立完整的 webpack 环境。启动 webpack 时，只会创建一次 compiler ，并配置所有的操作设置，包括选项、加载器和插件。在 webpack 环境中，compiler 会作为一个参数引入插件。通过 compiler 可以访问 webpack 的基本环境。</p>
<p>Compiler 继承自 Tapable，使得 webpack 实例具备注册和调用 plugin 的功能。</p>
<p>Webpack 在调用 plugin 时，首先创建子 compiler 来委派特定的任务:</p>
<pre><code>function webpack(options, callback) {
    <span class="keyword">let</span> compiler;
      <span class="keyword">if</span>(<span class="built_in">Array</span><span class="built_in">.</span>isArray(options)) {
        compiler = <span class="literal">new</span> MultiCompiler(options<span class="built_in">.</span><span class="built_in">map</span>(options =&gt; webpack(options)));
   } <span class="keyword">else</span> <span class="keyword">if</span>(typeof options === <span class="string">"object"</span>) {
           <span class="attribute">...</span>
           compiler = <span class="literal">new</span> Compiler();
           <span class="attribute">...</span>
      } <span class="keyword">else</span> {
          <span class="attribute">...</span>
      }
      <span class="attribute">...</span>
      <span class="keyword">return</span> compiler;
}
</code></pre><p>Webpack 的实际入口是 Compiler 类的 run 方法， 在 run 方法里调用 compile 方法开始编译。在编译的时候会使用一个核心对象：Compilation。</p>
<h2 id="Compilation">Compilation</h2><blockquote>
<p>A compilation object represents a single build of versioned assets. While running webpack development middleware, a new compilation will be created each time a file change is detected, thus generating a new set of compiled assets. A compilation surfaces information about the present state of module resources, compiled assets, changed files, and watched dependencies. The compilation also provides many callback points at which a plugin may choose to perform custom actions.</p>
</blockquote>
<p>Compilation 对象是每次进行资源构建的一个版本。每当检测到一个文件变化，一次新的编译将被创建，从而生成一组新的编译资源。该对象负责组织整个编译过程，内部存放着所有 module，chunk，生成的 asset 以及用来生成最后打包文件的 template 的信息。</p>
<pre><code><span class="comment">// Compiler对象的引用</span>
<span class="keyword">this</span>.compiler = compiler; 

<span class="comment">//模块解析器      </span>
<span class="keyword">this</span>.resolvers = compiler.resolvers; 
...

<span class="comment">// 生成js结果文件的Template</span>
<span class="keyword">this</span>.mainTemplate = <span class="keyword">new</span> MainTemplate(<span class="keyword">this</span>.outputOptions);
<span class="keyword">this</span>.chunkTemplate = <span class="keyword">new</span> ChunkTemplate(<span class="keyword">this</span>.outputOptions, <span class="keyword">this</span>.mainTemplate);
<span class="keyword">this</span>.hotUpdateChunkTemplate = <span class="keyword">new</span> HotUpdateChunkTemplate(<span class="keyword">this</span>.outputOptions);
<span class="keyword">this</span>.moduleTemplate = <span class="keyword">new</span> ModuleTemplate(<span class="keyword">this</span>.outputOptions);
<span class="comment">// 入口</span>
<span class="keyword">this</span>.entries = [];
<span class="comment">// 预先加载的chunk</span>
<span class="keyword">this</span>.preparedChunks = [];
<span class="comment">// 所有的chunk</span>
<span class="keyword">this</span>.chunks = [];                               
<span class="keyword">this</span>.namedChunks = {};
<span class="comment">// 所有module                             </span>
<span class="keyword">this</span>.modules = [];              
...

<span class="comment">// 保存所有生成的文件</span>
<span class="keyword">this</span>.assets = {}; 

<span class="comment">// 保存子Compilation对象，子Compilation对象依赖父级Compilation对象生成的结果</span>
<span class="keyword">this</span>.children = []; 
<span class="comment">// 保存Dependency和ModuleFactory的对应关系，方便创建该依赖对应的Module           </span>
<span class="keyword">this</span>.dependencyFactories = <span class="keyword">new</span> ArrayMap();  
<span class="keyword">this</span>.dependencyTemplates = <span class="keyword">new</span> ArrayMap();  
</code></pre><p>plugin 注册了 make 事件的监听，当 Compiler 执行 make 事件流时，调用 Compilation.addEntry 方法，通过 options 对象的 entry 字段找到入口脚本，调用 _addModuleChain 方法根据模块类型通过模块工厂创建和构建 Module：</p>
<pre><code>_addModuleChain(context, dependency, onModule, callback) {
    ...
    <span class="regexp">//</span> 创建模块
    const moduleFactory = <span class="keyword">this</span>.dependencyFactories.get(dependency.constructor);
    ...
    moduleFactory.create(context, dependency, <span class="function"><span class="params">(err, <span class="built_in">module</span>)</span> =&gt;</span> {
        const result = <span class="keyword">this</span>.addModule(<span class="built_in">module</span>);
        ...

        <span class="regexp">//</span> 构建模块，使用acorn生成AST，添加依赖模块
        <span class="keyword">this</span>.buildModule(<span class="built_in">module</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="function"><span class="params">(err)</span> =&gt;</span> {
            ...
        });
    });
};
</code></pre><p>完成 buildModule 后，程序调用 processModuleDependencies 开始递归处理依赖的 module：</p>
<pre><code>addModuleDependencies(module, dependencies, bail, cacheGroup, recursive, callback) {
    <span class="comment">// 根据 dependencies 创建依赖模块对象</span>
    const factories = [];
    <span class="keyword">for</span>(let i = <span class="number">0</span>; i &lt; dependencies.length; i++) {
        const factory = <span class="built_in">_this</span>.dependencyFactories.get(dependencies[i][<span class="number">0</span>].constructor);
        <span class="keyword">if</span>(!factory) {
            return callback(new Error(`No module factory available <span class="keyword">for</span> dependency <span class="built_in">type</span>: ${dependencies[i][<span class="number">0</span>].constructor.<span class="built_in">name</span>}`));
        }
        factories[i] = [factory, dependencies[i]];
    }
    <span class="comment">// 遍历每个依赖模块</span>
    async.<span class="keyword">forEach</span>(factories, function iteratorFactory(item, callback) {
        <span class="comment">// 构建模块</span>
        ...
    });
    ...
}
</code></pre><p>所有模块构建完成后，开始调用 seal 方法对构建结果进行封装，对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash。在封装过程中，webpack 会调用 Compilation 中的 createChunkAssets 方法进行代码生成，通过判断是否为入口文件来选择不同的模板对象进行封装，入口文件会采用 mainTemplate 加载的 render 方法，其余文件则采用异步加载的 chunkTemplate 的 render 方法。</p>
<pre><code><span class="comment">// 如果是入口，则使用 MainTemplate 生成结果，否则使用 ChunkTemplate</span>
<span class="keyword">if</span>(chunk.hasRuntime()) {
    source = <span class="keyword">this</span>.mainTemplate.render(<span class="keyword">this</span>.hash, chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);
} <span class="keyword">else</span> {
    source = <span class="keyword">this</span>.chunkTemplate.render(chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);
}

<span class="comment">// chunk.hasRuntime</span>
hasRuntime() {
    <span class="keyword">if</span>(<span class="keyword">this</span>.entrypoints.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>.entrypoints[<span class="number">0</span>].chunks[<span class="number">0</span>] === <span class="keyword">this</span>;
}
</code></pre><h2 id="Template">Template</h2><p>Template是用来生成结果代码的。webpack 中 Template 有四个子类：</p>
<ul>
<li>MainTemplate 用于生成项目入口文件</li>
<li>ChunkTemplate 用于生成异步加载的代码</li>
<li>ModuleTemplate 用于生成某个模块的代码</li>
<li>HotUpdateChunkTemplate 用于处理热替换模块</li>
</ul>
<p>在 MainTemplate 和 ChunkTemplate 需要根据依赖的模块，逐个调用 ModuleTemplate 的 render 方法：</p>
<pre><code> <span class="keyword">this</span>.plugin(<span class="string">"require-extensions"</span>, (<span class="keyword">source</span>, chunk, hash) =&gt; {
     ...
     <span class="keyword">this</span>.requireFn = <span class="string">"__webpack_require__"</span>;
 });
 render(hash, chunk, moduleTemplate, dependencyTemplates) {
     var buf = [];
      ...
     buf.<span class="keyword">push</span>(<span class="string">"function "</span> + <span class="keyword">this</span>.requireFn + <span class="string">"(moduleId) {"</span>);
     buf.<span class="keyword">push</span>(<span class="keyword">this</span>.indent(<span class="keyword">this</span>.applyPluginsWaterfall(<span class="string">"require"</span>, <span class="string">""</span>, chunk, hash)));
     buf.<span class="keyword">push</span>(<span class="string">"}"</span>);
     buf.<span class="keyword">push</span>(<span class="string">""</span>);
     ...
};
</code></pre><p>ModuleTemplate 根据 dependencyTemplates 获取不同的依赖 Template 实例：</p>
<pre><code>render(<span class="keyword">module</span>, dependencyTemplates, chunk) {
    <span class="keyword">const</span> moduleSource = <span class="keyword">module</span>.source(dependencyTemplates, <span class="keyword">this</span>.outputOptions, <span class="keyword">this</span>.requestShortener);
    <span class="keyword">const</span> moduleSourcePostModule = <span class="keyword">this</span>.applyPluginsWaterfall(<span class="string">"module"</span>, moduleSource, <span class="keyword">module</span>, chunk, dependencyTemplates);
    <span class="keyword">const</span> moduleSourcePostRender = <span class="keyword">this</span>.applyPluginsWaterfall(<span class="string">"render"</span>, moduleSourcePostModule, <span class="keyword">module</span>, chunk, dependencyTemplates);
    <span class="keyword">return</span> <span class="keyword">this</span>.applyPluginsWaterfall(<span class="string">"package"</span>, moduleSourcePostRender, <span class="keyword">module</span>, chunk, dependencyTemplates);
};
</code></pre><p>module.source()方法是生成该模块结果代码的方法。source 是一个抽象方法，在 Module 的不同子类里会重写该方法。在子类 NormalModule 的 source 方法里，会根据依赖的 Templete 把源代码替换成 webpack 的模块加载代码：</p>
<pre><code>source(dependencyTemplates, runtimeTemplate) {
    <span class="keyword">const</span> hashDigest = <span class="keyword">this</span>.getHashDigest(dependencyTemplates);
    <span class="keyword">if</span> (<span class="keyword">this</span>._cachedSourceHash === hashDigest) {
        <span class="comment">// We can reuse the cached source</span>
        <span class="keyword">return</span> <span class="keyword">this</span>._cachedSource;
    }

    <span class="keyword">const</span> source = <span class="keyword">this</span>.generator.generate(
        <span class="keyword">this</span>,
        dependencyTemplates,
        runtimeTemplate
    );

    <span class="keyword">const</span> cachedSource = <span class="keyword">new</span> CachedSource(source);
    <span class="keyword">this</span>._cachedSource = cachedSource;
    <span class="keyword">this</span>._cachedSourceHash = hashDigest;
    <span class="keyword">return</span> cachedSource;
}
</code></pre><p>最后 webpack 会在 Compiler 的 emitAssets 方法里创建输出目录，把 compilation.assets 的结果写入输出文件。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/23/web performance/" itemprop="url">
                  前端优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2018-03-23T00:00:00+08:00" content="2018-03-23">
              2018-03-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/23/web performance/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/23/web performance/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>影响用户浏览网页的速度主要有以下几条因素：</p>
<ul>
<li>用户网速</li>
<li>服务器所在线路</li>
<li>DNS解析</li>
<li>服务器负载</li>
<li>服务器端运行速度</li>
<li>前端页面加载</li>
</ul>
<p>优化前端可以直观地影响用户体验，同时也是成本较低的优化方式。  </p>
<p>前端的优化可以从两方面入手：  </p>
<ul>
<li>加载优化</li>
<li>渲染优化</li>
</ul>
<h2 id="前端优化辅助工具">前端优化辅助工具</h2><p>我们可以借助Google官方的PageSpeed Tools来分析页面加载速度，这个检测工具有在线版本，也有Chrome和Firefox扩展：<a href="https://developers.google.com/speed/pagespeed/" target="_blank" rel="external">PageSpeed Insights</a>。</p>
<p><img src="http://7xowup.com1.z0.glb.clouddn.com/web-perform-1.png" alt="PageSpeed Insights phone"></p>
<p><img src="http://7xowup.com1.z0.glb.clouddn.com/web-perform-2.png" alt="PageSpeed Insights web"></p>
<p>如果使用<a href="https://developers.google.com/web/tools/lighthouse/?hl=zh-cn" target="_blank" rel="external">Lighthouse</a>进行分析，会生成更加全面和详细的报告：</p>
<p><img src="https://developers.google.cn/web/fundamentals/performance/why-performance-matters/images/lighthouse-2x.png" alt="lighthouse"></p>
<p>Lighthouse除了可以安装扩展外，还可以通过npm安装在本地，通过命令行调用：</p>
<pre><code>npm install -<span class="keyword">g</span> lighthouse

<span class="comment">// 使用lighthouse</span>
lighthouse --<span class="keyword">view</span> http:<span class="comment">//...</span>
</code></pre><h2 id="前端优化原则">前端优化原则</h2><p>Yslow-23条规则如下：</p>
<h4 id="减少HTTP请求数">减少HTTP请求数</h4><ul>
<li>合并CSS</li>
<li>合并JS</li>
<li>CSS Sprites</li>
</ul>
<h4 id="使用CDN">使用CDN</h4><ul>
<li>优点：提高用户访问速度</li>
<li>缺点：只适合静态内容，内容的改变无法立刻同步到所有服务器上</li>
</ul>
<h4 id="避免过多DNS">避免过多DNS</h4><p>一旦用户的浏览器和用户的计算机DNS缓存都没有记录请求的地址，则浏览器就要进行一次远程的DNS解析。</p>
<p>影响用户每次浏览DNS查找数量的因素主要有：</p>
<ol>
<li>操作系统DNS 缓存的时间</li>
<li>浏览器缓存的时间和数量</li>
<li>发布到DNS服务器的TTL时间</li>
<li>同一个页面请求的不同域名的数量</li>
<li>Keep-Alive时间</li>
</ol>
<p>前端无法控制前三条因素；<br>第4条，前端应该尽量减少域名的数量，但是增加不同的域名也可以提高并行下载的速度，需要根据实际业务衡量权重；<br>第5条，Keep-Alive可以使我们减少请求tcp-ip的时间，同时不需要DNS解析，但是会额外增加服务器的负担。</p>
<h4 id="避免无效的链接">避免无效的链接</h4><p>检查链接地址是否有效</p>
<h4 id="HTTP请求头使用Expires和Cache-Control">HTTP请求头使用Expires和Cache-Control</h4><ul>
<li>Last-Modified：在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</li>
<li><p>If-Modified-Since：客户端第二次请求此URL时，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过，如果服务器端的资源没有变化，则自动返回 HTTP 304，内容为空，节省了传输数据量。</p>
</li>
<li><p>Expires：声明资源不再被浏览器缓存的时间，一旦超过了这个时间，浏览器都应该重新发送请求给服务器。</p>
</li>
<li><p>Cache-Control: 如果指定cache-control的值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值，那么在此值内的时间里就不会重新访问服务器。</p>
</li>
<li><p>Etag: 比Last-Modified更保险，在缓存没有过期的情况下，根据If-None-Match判断该请求自上次客户端请求之后是否有修改，若未被修改则返回响应304（Not Modified）和一个空的响应头。  </p>
</li>
</ul>
<h4 id="HTTP请求头使用Etag">HTTP请求头使用Etag</h4><blockquote>
<p>Etag响应头部字段值是一个实体标记，它提供一个 “不透明” 的缓存验证器。这可能在以下几种情况下提供更可靠的验证：不方便存储修改日期；HTTP 日期值的 one-second 解决方案不够用；或者原始服务器希望避免由于使用修改日期而导致的某些冲突。</p>
</blockquote>
<p><strong>请求流程</strong>  </p>
<p>Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。</p>
<p>请求一个文件的流程可能如下：</p>
<p>—– 第一次请求 —–</p>
<ol>
<li>客户端发起 HTTP GET 请求；  </li>
<li>服务器处理请求，返回文件内容和Header，包括Etag：2e681a65d044840，状态码200。</li>
</ol>
<p>—– 第二次请求 —–  </p>
<ol>
<li>客户端发起 HTTP GET 请求，同时发送一个If-None-Match：2e681a65d044840，也就是第一次请求得到的Etag值；</li>
<li>服务器比较客户端的If-None-Match和服务器的Etag，若一致则返回空内容，状态码304；</li>
<li>客户端继续使用本地缓存，状态码200。</li>
</ol>
<p>Etag 主要为了解决 Last-Modified 无法解决的一些问题： </p>
<ul>
<li>一些文件也许会周期性的更改，但是他的内容并不改变，仅仅改变的修改时间，这个时候我们并不希望客户端认为这个文件被修改了而重新请求；</li>
<li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，而UNIX记录MTIME只能精确到秒；</li>
<li>某些服务器不能精确得到文件的最后修改时间；</li>
<li>……</li>
</ul>
<p>Etag 仅仅是一个和文件相关的实体值标记，可以是一个版本标记，比如v1.0.0也是合法的。</p>
<h5 id="避免重定向。">避免重定向。</h5><p>同域：注意避免反斜杠 “/” 的跳转；<br>跨域：使用Alias或者mod_rewirte建立CNAME（保存域名与域名之间关系的DNS记录）。</p>
<h4 id="压缩">压缩</h4><ul>
<li><p>压缩内容： 一般的HTML 、CSS、JS文件都应该采用Gzip进行压缩，而图片和PDF文档不应该被压缩，因为他们已经被本地压缩过，在进行压缩不会获得效果，而且会增加服务器的压力。</p>
</li>
<li><p>压缩效果<br>Gzip是一个免费的压缩方法，快速而有效，通常能减少70%的文件大小，并被几乎所有的浏览器所支持。</p>
</li>
</ul>
<h4 id="样式文件尽量放在页面头部">样式文件尽量放在页面头部</h4><p>首屏加载最直观的表现在于页面样式。</p>
<h4 id="脚本文件尽量放在页面底部">脚本文件尽量放在页面底部</h4><p>防止脚本加载对之后资源造成阻塞。</p>
<h4 id="尽量不使用CSS表达式">尽量不使用CSS表达式</h4><h4 id="避免过多的内联JS和CSS">避免过多的内联JS和CSS</h4><ul>
<li>内联优势：可以减少HTTP请求数，可能会导致第一次请求所需时间过长；</li>
<li>外置优势：可以使用CDN静态缓存，可以被浏览器缓存，组件重用率提高。</li>
</ul>
<p>这条规则与第一条，减少HTTP请求是互相矛盾的，所以需要均衡，衡量的标准主要是重用率和访问页面的次数。如果网站的页面一个用户只会浏览几次，或者页面中的CSS、JS相对独立，适合选择内联。一般来讲，外置都会获得更好的性能，还可以采用动态内联和加载后下载的方式，用cookie记录用户是否有缓存，如果没有，则在用户页面显示完毕之后，采用JS的方式动态加载，但是需要放置CSS冲突和JS冲突。</p>
<h4 id="删除重复的JS和CSS">删除重复的JS和CSS</h4><p>重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。</p>
<h4 id="压缩JavaScript和CSS文件">压缩JavaScript和CSS文件</h4><h4 id="AJAX请求缓存">AJAX请求缓存</h4><p>“异步”并不意味着“即时”，AJAX 并不能保证用户不会在等待异步的JavaScript和XML响应上花费时间。</p>
<h4 id="使用GET来完成AJAX请求">使用GET来完成AJAX请求</h4><p>当使用 XMLHttpRequest 时，浏览器中的 POST 方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据和进行缓存策略则更有意义。</p>
<h4 id="减少DOM渲染节点">减少DOM渲染节点</h4><h4 id="图片尺寸不要作伸缩">图片尺寸不要作伸缩</h4><h4 id="尽量减小Cookie的体积">尽量减小Cookie的体积</h4><h4 id="不要使用滤镜">不要使用滤镜</h4><h4 id="不同域名下的Cookie彼此独立">不同域名下的Cookie彼此独立</h4><p>不同域名下的Cookie不要都设在根域名下，会增加请求头的大小。Yahoo! 的静态文件都在主域名以外，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。</p>
<h4 id="避免404">避免404</h4><p>有些站点把404错误响应页面改为“你是不是要找……”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。</p>
<h4 id="缩小favicon-ico并缓存">缩小favicon.ico并缓存</h4>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/17/regx/" itemprop="url">
                  正则表达式总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2018-03-17T00:00:00+08:00" content="2018-03-17">
              2018-03-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/17/regx/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/17/regx/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="语法">语法</h2><h3 id="基本字符">基本字符</h3><p>. ： 匹配除了换行符之外的任何单个字符。<br>\ ： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。<br>| ： 逻辑或操作符。<br>[] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像.，\这些字符都表示其本身。<br>[^] ：对一个集合取非。<br>- ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面。<br>() ：分组。<br>(?:) ： 匹配分组但不捕获该分组。</p>
<h3 id="数量字符">数量字符</h3><p>{m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，{m}表示匹配 m 次，{m,}表示至少 m 次。<br>+ ： 匹配前面一个表达式一次或者多次，相当于 {1,}，至少 1 次。<br>* ： 匹配前面一个表达式零次或者多次，相当于 {0,}，至少 0 次。<br>? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，如果跟在任何量词*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。</p>
<h3 id="定位字符">定位字符</h3><p>^ ： 匹配表达式的开始。<br>\$ ： 匹配表达式的结束。<br>\b ：匹配单词边界。<br>\B ：匹配非单词边界。<br>\A ：匹配字符串开头。<br>\Z ：匹配字符串结尾。<br>(?=p) ：匹配 p 前面的位置。(?&lt;=p)<br>(?!p) ：匹配不是 p 前面的位置。(?&lt;!p)  </p>
<h3 id="特殊字符">特殊字符</h3><p>\d ：表示一位数字，相当于[0-9]。（d = digit）<br>\D ：表示一位非数字 ，相当于[^0-9]。<br>\s ：表示空白符，包括空格，水平制表符（\t），垂直制表符（\v），换行符（\n），回车符（\r），换页符（\f），相当于[\t\v\n\r\f]。（s = space）<br>\S ：表示非空白符，相当于[^\t\v\n\r\f]。<br>\w ：表示数字大小写字母和下划线，相当于[0-9a-zA-Z]。(w = word)<br>\W ：表示非单词字符，相当于[^0-9a-zA-Z]。 </p>
<h3 id="标志字符">标志字符</h3><p>g ： 全局搜索。（g = global）<br>i ：不区分大小写。(i = ignore)<br>m ：多行搜索。(m = multi)</p>
<h2 id="运用">运用</h2><p>JS支持正则字符串的方法：</p>
<ul>
<li>split 返回一个分割字符串的数组</li>
<li>search 返回匹配到子串的起始位置，匹配不到返回-1 </li>
<li>replace 接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串。</li>
</ul>
<p>example:</p>
<pre><code><span class="comment">// 将'@@...@@'Markdown语法变成'&lt;blink&gt;...&lt;/blink&gt;'</span>
<span class="function"><span class="keyword">function</span> <span class="title">replaceMD</span>(<span class="params">str</span>) </span>{
    <span class="keyword">return</span> str.replace(<span class="regexp">/@@(.*?)@@/g</span>, <span class="string">"&lt;blink&gt;$1&lt;/blink&gt;"</span>)
}
<span class="keyword">var</span> rstr = replaceMD(<span class="string">'@@whatever@@'</span>);
<span class="built_in">console</span>.log(rstr); <span class="comment">// &lt;blink&gt;whatever&lt;/blink&gt;</span>

<span class="comment">/* 特殊变量 */</span>
<span class="comment">// $$ 插入一个 "$"  </span>
<span class="comment">// $&amp; 插入匹配的子串</span>
<span class="comment">// $` 插入当前匹配的子串左边的内容</span>
<span class="comment">// $' 插入当前匹配的子串右边的内容</span>
<span class="comment">// $n 插入第 n 个括号匹配的字符串</span>
</code></pre><ul>
<li>match 没有找到任何匹配的文本时返回 null ，否则返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本, 包含两个对象属性 index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。</li>
</ul>
<p>example:</p>
<pre><code><span class="comment">// 捕获正整数 x 的值</span>
<span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">str</span>) </span>{
  <span class="keyword">var</span> reg = <span class="regexp">/(?:x=)(\d+)/</span>;
  <span class="keyword">var</span> arr = str.match(reg);
  <span class="keyword">return</span> arr &amp;&amp; arr[<span class="number">1</span>] ? arr[<span class="number">1</span>] : arr;
}
getX(<span class="string">'beep x=123123 boop'</span>);

<span class="comment">/* console arr */</span>
<span class="comment">// 0: "x=123123"</span>
<span class="comment">// 1: "123123"</span>
<span class="comment">// index: 5</span>
<span class="comment">// input: "beep x=123123 boop"</span>
<span class="comment">// length: 2</span>
</code></pre><p>正则对象的方法：</p>
<ul>
<li>test 如果正则表达式与指定的字符串匹配返回 true，否则返回 false</li>
<li>exec 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回 null。</li>
</ul>
<h2 id="匹配">匹配</h2><p>基于量词（如?, +, *, {m,n}, {m,}）的字符重复次数匹配是正则表达式优于普通字符串处理方法的一个重要方面，也是正则表达式的一个重要组成部分。正则匹配方式有两种：</p>
<ul>
<li><strong>贪婪模式</strong> 匹配优先量词，包括：?, +, *, {m,n}，但是不包括{m}</li>
<li><strong>非贪婪模式</strong> 忽略优先量词，包括：??, +?, *?, {m,n}?</li>
</ul>
<p>匹配优先量词修饰的子表达式使用的是就是贪婪模式（非惰性匹配）;忽略优先量词修饰的子表达式使用的就是模式就是非贪婪模式（惰性匹配）。  </p>
<p>下面使用字符串”abc”来匹配两种正则表达式：</p>
<p>1.贪婪模式：.*  </p>
<pre><code>"         .*          "
<span class="header">|         |           |
-----------------------</span>
"   | -&gt;  |  -&gt; |  -&gt; "
|   a     b     c     |
<span class="header">|   |     |     |  &lt;- |
-----------------------</span>
</code></pre><p>首先将控制权交给“””，由它来匹配第一个字符”匹配成功，将控制权转交给“.<em>”，<br>这时候控制权掌握在了“.</em>”的手上，由于“<em>”是优先词量，在可匹配与不可匹配的情况下，优先尝试匹配，他就会尝试匹配第一字符“a”，<br>匹配成功就会继续往下匹配，匹配第二字符“b”，<br>匹配成功，继续向右匹配，直到匹配到结尾的“””，<br>匹配成功，再向后匹配时发现已经到结尾了，<br>“.</em>”结束匹配将控制权转交给“””，<br>“””发现已经到了源字符串的结尾，看有没有可供回溯的状态，将控制权给了“.<em>”，<br>“.</em>”还回一个字符“c”，然后将控制权转交给“””，来匹配后面的字符“””，匹配成功正则表达式结束。<br>这句表达式匹配过程中只进行了一次回溯。</p>
<p>2.非贪婪模式：.*?</p>
<pre><code><span class="string">"          .*?        "</span>
|<span class="string">          </span>|<span class="string">          </span>|
-----------------------
<span class="string">"   -&gt;| -&gt; | -&gt; |     "</span>
|<span class="string">   &lt;-</span>|<span class="string"> &lt;- </span>|<span class="string"> &lt;- </span>|<span class="string">     </span>|
|<span class="string">     a    b    c     </span>|
0     1    2    3     4
-----------------------
</code></pre><p>首先由第一个“””取得控制权，匹配位置0位的“””，匹配成功，控制权交给“.<em>?”。<br>“.</em>?”取得控制权后，由于“<em>?”是忽略优先量词，在可匹配可不匹配的情况下，优先尝试不匹配，由于“</em>”等价于“{0,}”，所以在忽略优先的情况下，可以不匹配任何内容。<br>从位置1处尝试忽略匹配，也就是不匹配任何内容，将控制权交给正则表达式最后的“””。 “””取得控制权后，从位置1处尝试匹配，由“””匹配位置1处的“a”，匹配失败，向前查找可供回溯的状态，控制权交给“.<em>?”，<br>由“.</em>?”吃进一个字符，匹配位置1处的“a”，再把控制权交给正则表达式最后的“””。<br>“””取得控制权后，从位置2处尝试匹配，由“””匹配位置1处的“a”，匹配失败，向前查找可供回溯的状态，重复以上过程，直到由“.*?”匹配到“c”为止，再把控制权交给正则表达式最后的“””。<br>“””取得控制权后，从位置4处尝试匹配，由“””匹配字符串最后的“””，匹配成功。<br>这句表达式匹配过程中进行了三次回溯。</p>
<p>贪婪模式与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配；非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。从匹配效率上来看，能达到相同匹配结果时，贪婪模式的匹配效率通常会比较高，因为它回溯过程会比较少。</p>
<h2 id="总结">总结</h2><p>分析正则表达式可以从结构和操作符两方面入手：结构有字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用；操作符像是转义符 \ ，括号和方括号 (…)、[…]，量词限定符 {m}、{m,n}、{m,}、?、*、+ ，和管道符 | 等等。操作符的优先级是从上到下，由高到低，在分析正则的时候可以根据优先级来拆分正则。</p>
<p>常见的正则表达式：  </p>
<p>匹配一个URL：</p>
<pre><code><span class="string">[a-zA-Z]</span>+://<span class="string">[\S]</span>+
</code></pre><p>匹配特定协议的网络地址，如http或http：</p>
<pre><code>(https?:<span class="comment">//)?[\S]+</span>
</code></pre><p>匹配一个IP地址：</p>
<pre><code><span class="list">(<span class="list">(<span class="list">(<span class="keyword">?:</span><span class="collection">[<span class="number">1</span><span class="number">-9</span>]</span>\d?)</span>|<span class="list">(<span class="keyword">?:1</span>\d<span class="collection">{<span class="number">2</span>}</span>)</span>|<span class="list">(<span class="keyword">?:2</span><span class="collection">[<span class="number">0</span><span class="number">-4</span>]</span>\d)</span>|<span class="list">(<span class="keyword">?:25</span><span class="collection">[<span class="number">0</span><span class="number">-5</span>]</span>)</span>)</span><span class="collection">[.]</span>)</span><span class="collection">{<span class="number">3</span>}</span><span class="list">(<span class="list">(<span class="keyword">?:</span><span class="collection">[<span class="number">1</span><span class="number">-9</span>]</span>\d?)</span>|<span class="list">(<span class="keyword">?:1</span>\d<span class="collection">{<span class="number">2</span>}</span>)</span>|<span class="list">(<span class="keyword">?:2</span><span class="collection">[<span class="number">0</span><span class="number">-4</span>]</span>\d)</span>|<span class="list">(<span class="keyword">?:25</span><span class="collection">[<span class="number">0</span><span class="number">-5</span>]</span>)</span>)</span>
</code></pre><p>匹配一个邮箱地址：</p>
<pre><code>[^\s@]+<span class="annotation">@[^\s@]</span>+\.[^\s@]+
</code></pre><p>匹配密码是否合法：</p>
<pre><code><span class="comment">// 要求必须同时包含且只能包含数字、大小字母、小写字母和标点符号：</span>
<span class="comment">(?=^[\d\Wa-zA-Z]{6,8}$)</span><span class="comment">(?=.*\d)</span><span class="comment">(?=.*[a-z])</span><span class="comment">(?=.*[A-Z])</span><span class="comment">(?=.*\W+)</span>
</code></pre><p>匹配大陆身份证号码（15位或18位）：</p>
<pre><code>\d{<span class="number">15</span>}|(\d{<span class="number">18</span>}|(\d{<span class="number">17</span>}[Xx]))
</code></pre><p>匹配日期（年-月-日）：</p>
<pre><code>(\d{2}|\d{4})-((0?[<span class="link_label">1-9</span>])|(1[<span class="link_label">0-2</span>]))-((0?[<span class="link_label">1-9</span>])|([<span class="link_label">12</span>][<span class="link_reference">0-9</span>])|(3[01]))
</code></pre><p>24小时制时间（小时:分钟:秒）：</p>
<pre><code>(((0?|1)[<span class="link_label">0-9</span>])|(2[<span class="link_label">0-3</span>])):([<span class="link_label">0-5</span>][<span class="link_reference">0-9</span>]):([<span class="link_label">0-5</span>][<span class="link_reference">0-9</span>])
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/08/webpack config/" itemprop="url">
                  Webpack Loader and Plugin
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2018-03-08T00:00:00+08:00" content="2018-03-08">
              2018-03-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/03/08/webpack config/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/08/webpack config/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Webpack是当前流行的JavaScript静态资源打包工具，可以根据四个核心设置Entry，Output，Loaders，Plugins来处理资源文件，构建各个module的依赖脉络。</p>
<h2 id="Webpack_Loader">Webpack Loader</h2><p>Webpack的loader可以针对不同类型的文件进行有效处理，转化成应用可以直接引用的模块，比如可以把sass转化成css，把ts或者es6代码转化成大部分浏览器都支持的es5。</p>
<p>在Webpack中，loader有两个主要的作用属性:</p>
<ul>
<li>test：需要进行转换的文件类型</li>
<li>use：转换需要的对应loader</li>
</ul>
<p>在webpack.config.js中配置loader：</p>
<pre><code><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);

<span class="keyword">const</span> config = {
  entry: <span class="string">'./path/to/my/entry/file.js'</span>,
  output: {
    path: path.resolve(__dirname, <span class="string">'dist'</span>),
    filename: <span class="string">'my-webpack.bundle.js'</span>
  },
  <span class="module"><span class="keyword">module</span>: </span>{
    rules: [
      { test: <span class="regexp">/\.scss$/</span>, use: <span class="string">'sass-loader'</span> }
    ]
  }
};

<span class="module"><span class="keyword">module</span>.exports = config;</span>
</code></pre><p>loader如果有多个，use的参数可以是数组，也可以设置各个loader的参数：</p>
<pre><code><span class="tag">module</span>: <span class="rules">{
  <span class="rule"><span class="attribute">rules</span>:<span class="value"> [
    {
      test: /\.css$/,
      use: [
        { loader: <span class="string">'style-loader'</span> </span></span></span>},
        <span class="rules">{
          <span class="rule"><span class="attribute">loader</span>:<span class="value"> <span class="string">'css-loader'</span>,
          options: {
            sourceMap:true,
            modules: true
          </span></span></span>}
        }
      ]
    }
  ]
}
</code></pre><p>常用的loader有:</p>
<ul>
<li><p>样式：style-loader、css-loader、less-loader、sass-loader等</p>
</li>
<li><p>文件：raw-loader、file-loader 、url-loader等</p>
</li>
<li><p>编译：babel-loader、coffee-loader 、ts-loader等</p>
</li>
<li><p>校验测试：mocha-loader、jshint-loader 、eslint-loader等</p>
</li>
</ul>
<p>babel-loader可以把ES6的代码转换成ES5代码。</p>
<p>file-loader可以复制和放置资源位置，指定文件名模板，也可以用hash命名以便缓存利用。</p>
<p>url-loader可以将小于配置limit参数的文件转换成data-url的方式，以便减少请求。</p>
<p>raw-loader可以读取文件，以字符串的形式返回。</p>
<p>imports-loader可以把文件以变量的形式向模块注入，比如注入jQuery：  </p>
<pre><code><span class="char">$,</span>imports-loader?<span class="char">$=</span>jquery // 相当于var <span class="char">$ </span>= require(<span class="comment">"jquery"</span>)
</code></pre><p>expose-loader可以设置对象为全局变量。</p>
<p>可以由此看出，loader本质就是接收字符串或者buffer，再返回处理完的字符串或者buffer。</p>
<p>除了常用的loader外，也可以根据实际生产环境自定义loader。比如需要把资源加载进模板的占位符：</p>
<pre><code><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>{
  <span class="keyword">return</span> getTemplete().replace(<span class="string">'{__templete_content__}'</span>, source)
}
</code></pre><h2 id="Webpack_Plugin">Webpack Plugin</h2><p>Webpack的plugin与loader的作用有点相似，都扩展了打包的功能，但是loader专注于资源转换，而plugin则可以执行更丰富或者复杂的任务，比如压缩，优化，重新定义环境变量。</p>
<p>配置plugin先用require方式引入，再用new操作符创建实例作为参数插入plugins数组，大部分plugin都可以通过选项进行定制。</p>
<p>在webpack.config.js中配置plugins：</p>
<pre><code><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);
<span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);
<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);

<span class="keyword">const</span> config = {
  entry: <span class="string">'./path/to/my/entry/file.js'</span>,
  output: {
    path: path.resolve(__dirname, <span class="string">'dist'</span>),
    filename: <span class="string">'my-first-webpack.bundle.js'</span>
  },
  <span class="module"><span class="keyword">module</span>: </span>{
    rules: [
      { test: <span class="regexp">/\.txt$/</span>, use: <span class="string">'raw-loader'</span> }
    ]
  },
  plugins: [
    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),
    <span class="keyword">new</span> HtmlWebpackPlugin({template: <span class="string">'./src/index.html'</span>})
  ]
};

<span class="module"><span class="keyword">module</span>.exports = config;</span>
</code></pre><p>在loader中虽然也可以进行html模板的替换，但是HtmlWebpackPlugin的接口配置比loader要丰富得多：</p>
<ul>
<li>title：用于生成的HTML文件的标题。</li>
<li>filename：用于生成的HTML文件的名称，默认是index.html，可以在这里指定子目录。</li>
<li>template：模板文件路径，支持加载器，比如 html!./index.html</li>
<li>inject：true | ‘head’ | ‘body’ | false，注入所有的资源到特定的template或templateContent中，如果设置为true或者body，所有的javascript资源将被放置到body元素的底部，’head’将放置到head元素中。</li>
<li>favicon：添加特定的favicon路径到输出的 HTML 文件中。</li>
<li>minify：压缩HTML文件，removeComments为true移除HTML中的注释，collapseWhitespace为true删除空白符与换行符。</li>
<li>hash：true | false，如果为true，将添加一个唯一的webpack编译hash到所有包含的脚本和CSS文件，对于cache管理很有用。</li>
<li>cache：true | false，如果为true，仅在文件修改之后才会发布文件。</li>
<li>showErrors：true | false，如果为true，错误信息会写入到页面中。</li>
<li>chunks：允许只添加某些块（比如unit、test）。</li>
<li>chunksSortMode：用于控制块在添加到页面之前的排序方式。</li>
<li>excludeChunks：允许跳过某些块（比如unit、test）。</li>
</ul>
<p>同样plugin也可以根据生产环境进行定制，通过plugin你可以访问compliler和compilation过程，通过钩子控制webpack的执行流程，从这里可以看出plugin会比loader更适合做复杂的任务。</p>
<p>一个完整的webpack插件需要满足以下几条规则和特征：</p>
<ul>
<li>是一个独立的模块。</li>
<li>模块对外暴露一个js函数。</li>
<li>函数的原型prototype上定义了一个注入compiler对象的apply方法。</li>
<li>apply函数中需要有通过compiler对象挂载的webpack事件钩子，钩子的回调中能获取当前编译的compilation对象，如果是异步编译的话则可以获取callback。</li>
<li>完成自定义子编译流程并处理complition对象的内部数据。</li>
<li>如果异步编译插件的话，数据处理完成后执行callback。</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/26/event/" itemprop="url">
                  JavaScript事件和事件模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2018-02-26T00:00:00+08:00" content="2018-02-26">
              2018-02-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/26/event/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/26/event/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="事件">事件</h2><p>事件是可以被控件识别的操作。在前端领域，事件指与浏览器或文档交互的瞬间，如点击按钮，填写表格等。在现代浏览器中内置大量的事件处理器，如Window事件、表单事件、鼠标事件、媒介事件等。<br>事件流描述的是事件发生的顺序。</p>
<h3 id="事件流">事件流</h3><p>事件流有两种:  </p>
<ul>
<li>事件冒泡（Event Capturing）: 是一种从下往上的传播方式。事件最开始由最具体的元素(文档中嵌套层次最深的节点, 也就是DOM最低层的子节点), 然后逐渐向上传播到最不具体的那个节点，也就是DOM中最高层的父节点。  </li>
<li>事件捕获（Event Bubbling）: 与事件冒泡相反。事件的处理将从DOM层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递。在这个过程中，事件会被从文档根到事件目标元素之间各个继承派生的元素所捕获，如果事件监听器在被注册时设置了useCapture属性为true，那么它们可以被分派给这期间的任何元素以对事件做出处理；否则，事件会被接着传递给派生元素路径上的下一元素，直至目标元素。</li>
</ul>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3071504079,3576946828&amp;fm=27&amp;gp=0.jpg" alt=""></p>
<h3 id="事件对象">事件对象</h3><p>当一个事件被触发时，会创建一个事件对象(Event Object), 这个对象里面包含了与该事件相关的属性或者方法。该对象会作为第一个参数传递给监听函数。</p>
<p>DOM事件模型中的事件对象常用属性:  </p>
<ul>
<li>type：获取事件类型</li>
<li>target：获取事件目标</li>
<li>stopPropagation()：阻止事件冒泡</li>
<li>preventDefault()：阻止事件默认行为</li>
</ul>
<p>IE事件模型中的事件对象常用属性:</p>
<ul>
<li>type：获取事件类型</li>
<li>srcElement：获取事件目标</li>
<li>cancelBubble：阻止事件冒泡</li>
<li>returnValue阻止事件默认行为</li>
</ul>
<h2 id="事件模型">事件模型</h2><h3 id="DOM0级事件模型">DOM0级事件模型</h3><p>DOM0级事件模型又称为原始事件模型，是早期的事件模型，所有的浏览器都是支持的，即直接在DOM对象上注册事件：</p>
<p>HTML中直接绑定：</p>
<pre><code>&lt;input id=<span class="string">"btn"</span> <span class="class"><span class="keyword">type</span></span>=<span class="string">"button"</span> onclick=<span class="string">"fun()"</span>&gt;
</code></pre><p>JS中绑定DOM：</p>
<pre><code><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);
btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>{
   alert(event.target);
};
</code></pre><p>解除绑定事件：</p>
<pre><code>btn.onclick = <span class="literal">null</span>;
</code></pre><p>在该模型中，事件不会传播，没有事件流的概念。一个DOM对象只能注册一个同类型的函数，注册多个同类型的函数则会发生覆盖。</p>
<h3 id="IE事件模型">IE事件模型</h3><p>IE8及之前的版本有特定的IE事件模型，该模型有两个阶段:  </p>
<ol>
<li>目标阶段(target phase)：事件到达目标元素, 触发目标元素的监听函数。    </li>
<li>冒泡阶段(bubbling phase)：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
</ol>
<p>事件绑定：</p>
<pre><code><span class="function"><span class="title">attachEvent</span><span class="params">(eventType, handler)</span></span>
</code></pre><p>事件解除：</p>
<pre><code><span class="function"><span class="title">detachEvent</span><span class="params">(eventType, handler)</span></span>
</code></pre><h3 id="DOM2级事件模型">DOM2级事件模型</h3><p>该模型是由W3C标准制定的，除了IE8及之前的版本不支持外，现代浏览器都支持。该模型中有三个阶段：  </p>
<ol>
<li>捕获阶段(capturing phase)：事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。  </li>
<li>目标阶段(target phase)：事件到达目标元素, 触发目标元素的监听函数。  </li>
<li>冒泡阶段(bubbling phase)：事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
</ol>
<p>事件绑定：</p>
<pre><code><span class="function"><span class="title">addEventListener</span><span class="params">(eventType, handler, useCapture)</span></span>
</code></pre><p>事件解除：</p>
<pre><code><span class="function"><span class="title">removeEventListener</span><span class="params">(eventType, handler, useCapture)</span></span>
</code></pre><p>参数 useCapture: boolean 用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致。</p>
<p>如果将useCapture设为true，指定在捕获阶段进行处理的话：</p>
<p>HTML: </p>
<pre><code>&lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"outer"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="property">id</span>=<span class="string">"inner"</span>&gt;inner&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>JS:</p>
<pre><code><span class="keyword">var</span> inner = <span class="built_in">document</span>.getElementById(<span class="string">'inner'</span>);
<span class="keyword">var</span> outer = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>);
inner.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    alert(<span class="string">'inner'</span>);
}, <span class="literal">true</span>);
outer.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    alert(<span class="string">'outer'</span>);
}, <span class="literal">true</span>);
</code></pre><p>由于inner是嵌套在outer中的，所以首先捕获到outer事件，其次才捕获inner事件。那么结果就是outer首先执行，其次是inner执行。如果在冒泡阶段处理的话，则是先执行inner后执行outer。</p>
<p>一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。如果inner注册两个处理阶段的事件，一个是在捕获阶段，另一个是在冒泡阶段：</p>
<pre><code><span class="keyword">var</span> inner = <span class="built_in">document</span>.getElementById(<span class="string">'inner'</span>);
<span class="keyword">var</span> outer = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>);
inner.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    alert(<span class="string">'capture'</span>);
}, <span class="literal">true</span>);
inner.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    alert(<span class="string">'bubble'</span>);
}, <span class="literal">true</span>);
</code></pre><p>首先弹出的是capture，其次是bubble，该运行结果与注册的顺序有关，先注册则先执行。</p>
<h2 id="事件代理和委托">事件代理和委托</h2><p>事件在冒泡过程中会上传到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理或事件委托（Event delegation）。</p>
<p>在父节点注册事件监听函数:<br>HTML:  </p>
<pre><code>&lt;<span class="tag">div</span> id=<span class="string">"outer"</span>&gt;
    &lt;<span class="tag">input</span> type=<span class="string">"button"</span> value=<span class="string">"1"</span> id=<span class="string">"btn1"</span>&gt;
    &lt;<span class="tag">input</span> type=<span class="string">"button"</span> value=<span class="string">"2"</span> id=<span class="string">"btn2"</span>&gt;
    &lt;<span class="tag">input</span> type=<span class="string">"button"</span> value=<span class="string">"3"</span> id=<span class="string">"btn3"</span>&gt;
&lt;/div&gt;
</code></pre><p>JS:</p>
<pre><code><span class="keyword">var</span> outer = <span class="built_in">document</span>.getElementById(<span class="string">'outer'</span>);
outer.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>{
    alert(event.target.id)
});
</code></pre><h2 id="观察者模式和发布/订阅模式">观察者模式和发布/订阅模式</h2><h3 id="观察者模式">观察者模式</h3><p>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。<br>JS的事件模型就是一种观察者模式的体现，当对应的事件被触发时，监听该事件的所有监听函数都会被调用。</p>
<h3 id="发布/订阅模式">发布/订阅模式</h3><p>发布/订阅模式（Publish/Subscribe）属于广义上的观察者模式，是最常用的一种观察者模式的实现，并且从解耦和重用角度来看，更优于典型的观察者模式。</p>
<h3 id="两者区别">两者区别</h3><p>在观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出响应：</p>
<pre><code><span class="comment">╭</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╮</span>  <span class="comment">Fire</span> <span class="comment">Event</span>  <span class="comment">╭</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╮</span>
<span class="comment">│</span>             <span class="comment">│─────────────</span>&gt;<span class="comment">│</span>              <span class="comment">│</span>
<span class="comment">│</span>   <span class="comment">Subject</span>   <span class="comment">│</span>              <span class="comment">│</span>   <span class="comment">Observer</span>   <span class="comment">│</span>
<span class="comment">│</span>             <span class="comment">│</span>&lt;<span class="comment">─────────────│</span>              <span class="comment">│</span>
<span class="comment">╰</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╯</span>  <span class="comment">Subscribe</span>   <span class="comment">╰</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╯</span>
</code></pre><p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件，以此避免发布者和订阅者之间产生依赖关系：</p>
<pre><code><span class="comment">╭</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╮</span>                 <span class="comment">╭</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╮</span>   <span class="comment">Fire</span> <span class="comment">Event</span>   <span class="comment">╭</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╮</span>
<span class="comment">│</span>             <span class="comment">│</span>  <span class="comment">Publish</span> <span class="comment">Event</span>  <span class="comment">│</span>               <span class="comment">│───────────────</span>&gt;<span class="comment">│</span>              <span class="comment">│</span>
<span class="comment">│</span>  <span class="comment">Publisher</span>  <span class="comment">│────────────────</span>&gt;<span class="comment">│</span> <span class="comment">Event</span> <span class="comment">Channel</span> <span class="comment">│</span>                <span class="comment">│</span>  <span class="comment">Subscriber</span>  <span class="comment">│</span>
<span class="comment">│</span>             <span class="comment">│</span>                 <span class="comment">│</span>               <span class="comment">│</span>&lt;<span class="comment">───────────────│</span>              <span class="comment">│</span>
<span class="comment">╰</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╯</span>                 <span class="comment">╰</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╯</span>    <span class="comment">Subscribe</span>   <span class="comment">╰</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">╯</span>
</code></pre><h2 id="自定义事件">自定义事件</h2><p>自定义事件充分发挥了JavaScript的“事件驱动模型”，也是所谓的观察者模式，可以把复杂的逻辑解耦。</p>
<p>在元素绑定自定义事件：</p>
<pre><code>btn.addEventListener(<span class="string">"formSubmit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>{
    <span class="built_in">console</span>.info(<span class="string">"Custom data is: "</span>, event.detail);
}, <span class="literal">false</span>);
</code></pre><p>这与绑定内置的表单事件相比并没有什么差异，但自定义事件可以通过js创建和触发事件：</p>
<pre><code><span class="comment">// 创建</span>
<span class="keyword">let</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">"formSubmit"</span>, {
    detail: {
        <span class="keyword">value</span>: <span class="string">"special"</span>
    }
});

<span class="comment">// 触发</span>
btn.dispatchEvent(myEvent);
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent" target="_blank" rel="external">CustomEvent</a>还可以通过配置bubbles和cancelable属性来触发特制的事件。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/var&this/" itemprop="url">
                  变量提升 & this的指向
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2018-02-08T00:00:00+08:00" content="2018-02-08">
              2018-02-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/08/var&this/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/08/var&this/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="变量提升">变量提升</h2><h3 id="函数及变量的声明都将被提升到执行代码的最顶部">函数及变量的声明都将被提升到执行代码的最顶部</h3><p>函数声明：</p>
<pre><code>hello();

<span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);
}
</code></pre><p>变量声明：</p>
<pre><code>x = 5<span class="comment">;</span>
console.log(x)<span class="comment">;</span>
var x<span class="comment">;</span>
</code></pre><h3 id="变量初始化和函数表达式则不会被提升">变量初始化和函数表达式则不会被提升</h3><p>变量初始化：</p>
<pre><code><span class="variable"><span class="keyword">var</span> x</span> = <span class="number">5</span>;
console.log(x+y); <span class="comment">// NaN</span>
<span class="variable"><span class="keyword">var</span> y</span> = <span class="number">7</span>;
</code></pre><p>函数表达式：</p>
<pre><code><span class="keyword">add</span>(); <span class="comment">// TypeError: add is not a function</span>

<span class="keyword">var</span> ab = <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">()</span> <span class="comment">{}</span>;</span> <span class="comment">// 表达式</span>
<span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">()</span> <span class="comment">{}</span>;</span> <span class="comment">// new表达式</span>
(<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">()</span> <span class="comment">{}</span>);</span> <span class="comment">// 分组操作符只能包含表达式</span>
</code></pre><ul>
<li>块中的声明大部分都不会被现代浏览器提升，包括块中的隐式声明</li>
</ul>
<h2 id="this的指向">this的指向</h2><blockquote>
<p>this与当前执行环境，而非声明环境有关。  </p>
</blockquote>
<p>this的指向需要根据函数上下文来判断，一般指向函数执行时的当前对象，但也可以通过其它方式来改变它的指向。</p>
<h3 id="作为单独的函数被调用">作为单独的函数被调用</h3><pre><code><span class="keyword">var</span> name = <span class="string">"global"</span>;
<span class="function"><span class="keyword">function</span> <span class="title">echoName</span>(<span class="params"></span>) </span>{
  <span class="keyword">var</span> name = <span class="string">"func"</span>
  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// global</span>
}
echoName();
</code></pre><p>可以理解为add()是window的一个属性，于是this指向全局变量。</p>
<h3 id="作为构造函数被调用">作为构造函数被调用</h3><pre><code><span class="keyword">var</span> name = <span class="string">"global"</span>;
<span class="function"><span class="keyword">function</span> <span class="title">echoName</span>(<span class="params"></span>) </span>{
  <span class="keyword">this</span>.name = <span class="string">"func"</span>;
}

<span class="keyword">var</span> fn = <span class="keyword">new</span> echoName();
<span class="built_in">console</span>.log(fn.name); <span class="comment">// func</span>
</code></pre><p>构造函数中的this一般指向构造出来的实例化对象，但也有另一种情况：</p>
<pre><code><span class="comment">// 构造函数1</span>
<span class="function"><span class="keyword">function</span> <span class="title">echo1</span>(<span class="params"></span>) </span>{
  <span class="keyword">this</span>.name = <span class="string">"name1"</span>;
  <span class="keyword">return</span> { name: <span class="number">1</span> }; <span class="comment">// 返回一个对象</span>
}
<span class="keyword">var</span> echo1 = <span class="keyword">new</span> echo1();
<span class="built_in">console</span>.log(echo1.name); <span class="comment">// 1</span>

<span class="comment">// 构造函数2</span>
<span class="function"><span class="keyword">function</span> <span class="title">echo2</span>(<span class="params"></span>) </span>{
  <span class="keyword">this</span>.name = <span class="string">"name2"</span>;
  <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 返回一个非对象</span>
}
<span class="keyword">var</span> echo2 = <span class="keyword">new</span> echo2();
<span class="built_in">console</span>.log(echo2.name); <span class="comment">// name2</span>
</code></pre><p>当构造函数的返回值是一个对象时，this指向返回对象，<br>如果返回值不是对象时，this指向构造函数的实例对象。</p>
<h3 id="作为对象的方法被调用">作为对象的方法被调用</h3><pre><code><span class="keyword">var</span> Obj = {
  name: <span class="string">"obj"</span>,
  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
  }
}

Obj.say(); <span class="comment">// obj</span>
</code></pre><p>say()作为对象Obj的方法被Obj调用，this指向的便是Obj对象。<br>但如果使用表达式调用say方法的话：</p>
<pre><code><span class="keyword">var</span> Obj = {
  name: <span class="string">"obj"</span>,
  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
       <span class="built_in">console</span>.log(<span class="keyword">this</span>);
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
  }
}

<span class="keyword">var</span> echoName = Obj.say;
echoName(); <span class="comment">// 打印出window和空</span>
</code></pre><p>echoName是一个全局变量，把Obj.say先赋值给echoName再调用的话，this会指向window。</p>
<h3 id="使用call或者apply方法">使用call或者apply方法</h3><p>call()和apply()方法从Function对象的原型继承而来，使用call()和apply()方法会改变this的指向，其函数内部的this可绑定到 call()和apply()方法指定的第一个对象上。</p>
<pre><code><span class="keyword">var</span> Obj = {
  name: <span class="string">"obj"</span>,
  say: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>{
       <span class="keyword">this</span>.name = name;
       <span class="built_in">console</span>.log(<span class="keyword">this</span>);
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
  }
}
<span class="keyword">var</span> Obj2 = {
    name: <span class="string">"obj2"</span>
  };
  <span class="keyword">var</span> echoName = Obj.say;
  echoName.call(Obj2,<span class="number">2</span>); <span class="comment">// {name: 2} 2</span>
  <span class="built_in">console</span>.log(Obj.name); <span class="comment">// obj</span>
</code></pre><h3 id="使用bind方法">使用bind方法</h3><p>bind()和call、apply不同的是，bind是新创建一个函数，然后把当前上下文this绑定到bind()的参数对象中并返回该函数。bind后函数不会执行，只是返回一个改变了this指向的函数副本，而call和apply是直接执行函数。</p>
<pre><code><span class="keyword">var</span> Obj = {
  name: <span class="string">"obj"</span>,
  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">_say</span>(<span class="params"></span>) </span>{
      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);    
    }
    <span class="keyword">return</span> _say.bind(Obj);
  }()
}
Obj.say(); <span class="comment">// 空</span>
</code></pre><p>需要注意的是，函数表达式的声明不会被提升，所以在_say方法调用的时候，Obj还没有被定义，this指向的是全局变量window。<br>声明Obj后再调用_say方法则能打印出obj，此时this指向Obj:</p>
<pre><code><span class="keyword">var</span> Obj = {name: <span class="string">"obj"</span>};
Obj.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="function"><span class="keyword">function</span> <span class="title">_say</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);    
  }
  <span class="keyword">return</span> _say.bind(Obj);
}()
Obj.say(); <span class="comment">// obj</span>
</code></pre><h3 id="使用定时器setTimeout和setInterval">使用定时器setTimeout和setInterval</h3><pre><code><span class="keyword">var</span> Obj = {
  name: <span class="string">"time"</span>,
  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
    }, <span class="number">0</span>);
  }
}
Obj.say(); <span class="comment">// 空</span>
</code></pre><blockquote>
<p>超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。 ——《JavaScript高级程序设计》</p>
</blockquote>
<p>setTimeout和setInterval方法是挂在window对象下的。此时的this指向应该为全局变量window。</p>
<h3 id="ES6箭头函数">ES6箭头函数</h3><p>箭头函数有几个使用注意点:</p>
<ul>
<li><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
</li>
<li><p>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
</li>
<li><p>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
</li>
<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
</li>
</ul>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<p>定时器的示例中，若是把定时器的function改成箭头函数：</p>
<pre><code><span class="keyword">var</span> Obj = {
  name: <span class="string">"time"</span>,
  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    setTimeout(() =&gt; {
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);
    }, <span class="number">0</span>);
  }
}
Obj.say(); <span class="comment">// time</span>
</code></pre><p>此时定时器的this指向Obj对象。</p>
<h3 id="严格模式">严格模式</h3><ul>
<li>在全局作用域中，this指向window对象。</li>
<li>在全局作用域中，作为单独的函数被调用时，this指向undefined。</li>
<li>在全局作用域中，作为对象的方法被调用时，this指向调用函数的对象实例。</li>
<li>在全局作用域中，作为构造函数被调用时，this指向构造函数创建的对象实例。</li>
</ul>
<p>另外，严格模式创设了第三种作用域：eval作用域。<br>正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。<br>严格模式下，eval语句本身就是一个作用域，所生成的变量只能用于eval内部。</p>
<pre><code><span class="pi">"use strict"</span>;
<span class="keyword">var</span> x = <span class="number">2</span>;
<span class="built_in">console</span>.info(<span class="built_in">eval</span>(<span class="string">"var x = 5; x"</span>)); <span class="comment">// 5</span>
<span class="built_in">console</span>.info(x); <span class="comment">// 2</span>
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/02/subscriptions/" itemprop="url">
                  RxJs订阅问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2018-02-02T00:00:00+08:00" content="2018-02-02">
              2018-02-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/02/02/subscriptions/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/02/02/subscriptions/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>RxJS是一种针对异步数据流编程工具，或者叫响应式扩展编程。  </p>
</blockquote>
<p>RxJS的目标就是异步编程，Angular2引入RxJS为了就是让异步变得简单和可控。</p>
<h3 id="取消订阅">取消订阅</h3><p>RxJS的核心就是基于观察者模式开发的，关于观察者模式有个关键点要注意，订阅和取消订阅一定要成对出现，不取消容易造成重复订阅的bug，严重的话可能内存泄露。</p>
<p>以下是一个引入RxJs Subject的广播服务：</p>
<pre><code><span class="keyword">export</span> <span class="keyword">class</span> Broadcaster {
  <span class="keyword">private</span> _eventBus: Subject&lt;BroadcastEvent&gt;;

  <span class="constructor"><span class="keyword">constructor</span>() </span>{
    <span class="keyword">this</span>._eventBus = <span class="keyword">new</span> Subject&lt;BroadcastEvent&gt;();
  }

  broadcast(key: <span class="built_in">any</span>, data?: <span class="built_in">any</span>) {
    <span class="keyword">this</span>._eventBus.next({key, data});
  }

  on&lt;T&gt;(key: <span class="built_in">any</span>): Observable&lt;T&gt; {
    <span class="keyword">return</span> <span class="keyword">this</span>._eventBus.asObservable()
      .filter(event =&gt; event.key === key)
      .map(event =&gt; &lt;T&gt;event.data);
  }
}
</code></pre><p>其中Subject既是一个Observable，也是一个Observer(被观察者和观察者):</p>
<ul>
<li>更改数据时触发observer的next()进行传递；  </li>
<li>filter()根据key值返回一个新的Observable，调用next()传递event给下一个observer；  </li>
<li>map()根据event返回一个新的Observable，并调用next()传递event.data给下一个observer;  </li>
<li>最后将结果传递给页面的subscribe订阅块（订阅块用完要取消掉）。</li>
</ul>
<p>这个服务有一个不够完善的地方就是没有订阅块的取消，直接交给了页面组件处理，如果不了解观察者模式的人恐怕就会忘记取消订阅而出现重复的问题。</p>
<p>angular@v2~4的EventEmitter也是参考RxJS的产物，若用EventEmitter再写一个类似广播的服务，可以带一个尾巴用于取消订阅，把订阅和取消订阅封装在一起成对出现：</p>
<pre><code><span class="keyword">public</span> on(callback: <span class="built_in">any</span>, didLeave: <span class="built_in">any</span>): <span class="built_in">any</span> {
    <span class="keyword">let</span> subscriber = <span class="keyword">this</span>.emitter.subscribe(callback);
    didLeave.subscribe(() =&gt; {
      <span class="keyword">this</span>.unsubscribe(subscriber);
    });
    <span class="keyword">return</span> subscriber;
}
</code></pre><p>didLeave是ionView的页面离开Observable，并且这应该是一个SafeSubscriber，RxJs里SafeSubscriber在onCompleted和onError时会调用unsubscribe()。</p>
<p>关于angular1.x我也曾经遇到一个bug，就是监听路由stateChange时有重复累加的问题，跟没有取消订阅是一样的道理。</p>
<h3 id="管理订阅">管理订阅</h3><p>除了取消订阅这个操作，我们也可以使用takeUntil来管理subscription。</p>
<p>比如在页面组件离开时取消订阅的方式可以改成：</p>
<pre><code><span class="keyword">public</span> on(callback: <span class="keyword">any</span>, didLeave: <span class="keyword">any</span>): <span class="keyword">any</span> {
  <span class="keyword">return</span> <span class="keyword">this</span>.emitter
    .takeUntil(didLeave)
    .subscribe(callback);
}
</code></pre><p>其他操作符：</p>
<ul>
<li>take(n): 在停止observable前发出N个值。  </li>
<li>takeWhile(predicate): 通过断言来测试发出的值，如果一旦函数返回false，则完成observable。  </li>
<li>first(): 发出首个值和完成通知。  </li>
<li>first(predicate): 根据断言检查每个值，如果函数返回true，则发出值和完成通知。</li>
</ul>
<p>当有多个订阅时，可以把订阅组合成单个subscription，通过创建一个父订阅把其他subscriptions作为子merge进来，这样的话只取消父订阅就可以了。</p>
<h3 id="总结:">总结:</h3><ul>
<li>应该尽可能的使用takeUntil、takeWhile及其他操作符来管理RxJS subscriptions，而不是频繁地取消订阅。  </li>
<li>如果在一个组件中发现2个或以上的subscriptions，应该用组合形式来进行订阅和取消订阅的处理。  </li>
</ul>
<p>对于跨时间的复杂异步任务，回调和Promise捉襟见肘，(俗称回调地狱)，RxJS可以比较优雅地组合和控制。</p>
<p>相关文档：</p>
<ul>
<li><a href="http://reactivex.io/rxjs/class/es6/Subject.js~Subject.html" target="_blank" rel="external">RxJS DOC</a></li>
<li><a href="https://github.com/jhusain/observable-spec" target="_blank" rel="external">Specification for Observable</a></li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/17/tree/" itemprop="url">
                  无限树节点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-12-17T00:00:00+08:00" content="2016-12-17">
              2016-12-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/17/tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/17/tree/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>之前有在已知树节点的情况下做过两级树菜单，如果是未知树节点的情况下，有可能是无限节点的延伸，这时可以用ng的inclue功能来实现，html结构大概如下：</p>
<h4 id="HTML:">HTML:</h4><pre><code><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"list-unstyled"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"organ in $ctrl.organsList"</span> <span class="attribute">ng-click</span>=<span class="value">"$ctrl.selectOrgan(organ,'parent',$event)"</span>&gt;</span>
        <span class="comment"></span>
        <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">ng-include</span>=<span class="value">"'organ-children.html'"</span>&gt;</span><span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/ng-template"</span> <span class="attribute">id</span>=<span class="value">"organ-children.html"</span>&gt;</span><span class="handlebars"><span class="xml">
    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"organ in organ.children"</span> <span class="attribute">ng-click</span>=<span class="value">"$ctrl.selectOrgan(organ,'child',$event)"</span>&gt;</span>
        <span class="comment"></span>
        <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">ng-if</span>=<span class="value">"organ.hadChildren=='C02'"</span> <span class="attribute">ng-include</span>=<span class="value">"'organ-children.html'"</span>&gt;</span><span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">li</span>&gt;</span>
</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre><p>在子页面children.html的列表li也包着子页面本身，于是就像迭代自己一样可以形成未知的多级菜单。<br>如果一开始不是一次性获得整棵树，点击父节点才能获取子节点的话，还得注意使用阻止冒泡的方法来阻止父节点的事件。<br>ng的$event事件里就带有阻止冒泡方法stopPropagation()，点击节点的方法如下：</p>
<h4 id="JS:">JS:</h4><pre><code><span class="variable">$ctrl</span>.selectOrgan = <span class="keyword">function</span>(<span class="literal">item</span>,name,<span class="variable">$e</span>) {
    <span class="variable">$ctrl</span>.selected = item;
    if (!!name) {
        if (name == <span class="string">'child'</span>) {
            // 阻止冒泡
            <span class="variable">$e</span>.stopPropagation();
        }
        if (item.hadChildren == <span class="string">'C02'</span> &amp;&amp; !item.hasOwnProperty(<span class="string">'children'</span>)) {
            <span class="variable">$ctrl</span>.getData(item);
        }
    }
};
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/01/type/" itemprop="url">
                  JavaScript类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-11-01T00:00:00+08:00" content="2016-11-01">
              2016-11-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/01/type/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/01/type/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>上一篇笔记提到了赋值和复制的微妙区别，现在来整理一下理论。</p>
<p>JavaScript虽然没有类，但仍存在两种类型：</p>
<ul>
<li>原始类型 - 简单数据值</li>
<li>引用类型 - 对象，本质为指向内存位置的引用</li>
</ul>
<p>其他编程语言用栈储存原始类型，用堆储存引用类型，js则用一个变量对象追踪变流量的生存期，原始值被保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。</p>
<h4 id="原始类型">原始类型</h4><ul>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>null</li>
<li>undefined</li>
</ul>
<p>原始类型的变量值直接保存原始值，当原始值赋给一个变量时，每个变量有自己的一份数据拷贝。</p>
<h4 id="引用类型">引用类型</h4><p>引用值是引用类型的实例，就是对象，对象是属性的无序列表，js里的函数其实也是引用值。<br>引用类型不在变量中直接保存对象，所以引用值变量实际上并不包含对象的实例，而是一个指向了内存中实际对象所在位置的指针。</p>
<p>js有垃圾回收机制，使用引用类型时虽然不必担心内存非配，但最好在对象使用完毕后解除引用，让垃圾收集器对其内存进行释放，最佳解除手段是将对象置为null。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/10/=&copy/" itemprop="url">
                  “=”赋值和angular.copy()赋值的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-09-10T00:00:00+08:00" content="2016-09-10">
              2016-09-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/10/=&copy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/10/=&copy/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>刚开始在做以下这个案例时，<br><img src="http://7xowup.com1.z0.glb.clouddn.com/=&amp;copy.gif" alt="choose-member"><br>弹出插件的控制器传送的数据变量直接用了“=”来赋值，导致即使点击了插件的“取消”按钮，另一个控制器的数据也直接更新了，在此不需要即时更新，用户完成选择的时候才需要更新数据，这样的话用“=”就会形成一个即时更新的通道，所以应该用angular的copy来赋值才对。</p>
<p>还是以此场景为案例，详细来说说这两个赋值的区别：<br>内存里有一段地址储存了{name: “During”}这个数据，页面控制器的成员数据$scope.member指向了它，插件的控制器中的选择数据$scope.select也指向了它，当这两个控制器的数据通过angular的factory取出数据并使$scope.member = $scope.select的时候，事实上是让二者同时指向了该数据，因此一个变了另外一个也会跟着变。<br>如果用$scope.member = angular.copy($scope.select)，那就是先做了一份select数据的拷贝，也就是内存中多了另外一份数据，值相同但地址不同，然后让$scope.member指向了这份拷贝，所以二者指向了不同的内存地址，就不会相互影响了。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars0.githubusercontent.com/u/5902080?v=3&s=460" alt="Eating" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Eating</p>
        </div>
        <p class="site-description motion-element" itemprop="description">少不更事</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eating</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"eatingmiao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
